#!/usr/bin/env python

###############################################################################
##
##  Copyright 2014-2015 Jeet Sukumaran.
##
##  Licensed under the Apache License, Version 2.0 (the "License");
##  you may not use this file except in compliance with the License.
##  You may obtain a copy of the License at
##
##      http://www.apache.org/licenses/LICENSE-2.0
##
##  Unless required by applicable law or agreed to in writing, software
##  distributed under the License is distributed on an "AS IS" BASIS,
##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
##  See the License for the specific language governing permissions and
##  limitations under the License.
##
##  Based on ideas and code from "quickfind"::
##
##      quickfind
##      https://github.com/Refefer/quickfind
##      By Andrew Stanton.
##
################################################################################

"""
A utility to find, list, filter, and act on files or directories from your
shell, using dynamic fuzzy-matching of patterns as you type them in.
"""

# Imports {{{1
# ==============================================================================
import os
import sys
import termios
import heapq
import argparse
import curses
import fcntl
import struct
import fnmatch
import re
import itertools
import collections
import subprocess
try:
    from StringIO import StringIO # Python 2 legacy support: StringIO in this module is the one needed (not io)
except ImportError:
    from io import StringIO # Python 3
try:
    import fsnix.util as util
    walk = util.walk
except ImportError:
    walk = os.walk
if sys.version_info.major >= 3:
    unicode_str = lambda x: str(x)
else:
    unicode_str = lambda x: unicode(x, errors="ignore")
import shlex
import itertools
# }}}1

# Program Metadata {{{1
# ==============================================================================
__prog__ = os.path.basename(__file__)
__version__ = "3.0.0"
__description__ = __doc__
__author__ = 'Jeet Sukumaran'
__copyright__ = 'Copyright (C) 2015 Jeet Sukumaran.'
# }}}1

# Text Utilities {{{1
# ==============================================================================
def levenshtein(s1, s2):
    if len(s1) < len(s2):
        return levenshtein(s2, s1)

    # len(s1) >= len(s2)
    if len(s2) == 0:
        return len(s1)

    previous_row = xrange(len(s2) + 1)
    for i, c1 in enumerate(s1):
        current_row = [i + 1]
        for j, c2 in enumerate(s2):
            insertions = previous_row[j + 1] + 1 # j+1 instead of j since previous_row and current_row are one character longer
            deletions = current_row[j] + 1       # than s2
            substitutions = previous_row[j] + (c1 != c2)
            current_row.append(min(insertions, deletions, substitutions))
        previous_row = current_row

    return previous_row[-1]

def truncate_front(line, length=70, truncation_str="<"):
    reduce_amt = len(line) - length
    # If it already fits
    if reduce_amt <= 0 or length <= 0:
        return line
    reduce_amt += len(truncation_str) # for the ellipsis
    return truncation_str+line[reduce_amt:]

def truncate_middle(line, length=70, truncation_str="..."):
    reduce_amt = len(line) - length
    # If it already fits
    if reduce_amt <= 0 or length <= 0:
        return line
    reduce_amt += len(truncation_str) # for the ellipsis
    start = (len(line) / 2) - (reduce_amt / 2)
    end = start + reduce_amt
    return "{}{}{}".format(line[:start], truncation_str, line[end:])
# }}}1

# CURSES {{{1
# ==============================================================================

class Subscreen(object): # {{{2

    def __enter__(self):

        # clone stdout: this allows us to open
        # the curses window in a subshell and
        # print the result to the "real" stdout
        # on exit
        self.prev_stdout_fd = os.dup(sys.stdout.fileno())
        self.new_stdout_clone = os.open("/dev/tty", os.O_WRONLY)
        os.dup2(self.new_stdout_clone, sys.stdout.fileno()) # 1
        self.prev_stdout = sys.stdout

        # initialize screen
        self.stdscr = curses.initscr()
        curses.noecho()
        curses.cbreak()
        # self.stdscr.keypad(1)
        try:
            curses.start_color()
        except:
            pass
        self.cursor_setting = None
        try:
            self.cursor_setting = curses.curs_set(0)
        except:
            pass
        return self.stdscr

    def __exit__(self, exc_type, exc_value, traceback):

        # restore terminal
        # self.stdscr.keypad(0)
        if self.cursor_setting is not None:
            try:
                curses.curs_set(self.cursor_setting)
            except:
                pass
        curses.echo()
        curses.nocbreak()
        curses.endwin()

        # restore standard output
        os.dup2(self.prev_stdout_fd, self.prev_stdout.fileno())
        self.stdout = self.prev_stdout
# }}}2

class Display(object): # {{{2

    # class variables {{{3
    FIRST_ITEM_ROW_OFFSET = 3
    STATUS_BAR_OFFSET     = 2
    QUERY_ROW_OFFSET      = 1
    # }}}3

    # key codes {{{3
    class KeyCode(object):
        def __init__(self, name, is_special=False):
            self.name = name
            self.is_special = is_special
        def __str__(self):
            return self.name
    KEYCODES = collections.OrderedDict()
    KEYCODES[0] = KeyCode(name="NUL", is_special=True)
    for idx, c in enumerate("ABCDEFGHIJKLMNOPQRSTUVWXYZ"):
        KEYCODES[idx+1] = KeyCode(name="CTRL-{}".format(c), is_special=True)
    KEYCODES[27] = KeyCode(name="ESC", is_special=True)
    KEYCODES[28] = KeyCode(name="FS", is_special=True)
    for idx in range(32, 127):
        KEYCODES[idx] = KeyCode(name=chr(idx), is_special=False)
    KEYCODES[127] = KeyCode(name="DEL", is_special=True)
    KEYCODES[-65] = KeyCode(name="UP", is_special=True)
    KEYCODES[-66] = KeyCode(name="DOWN", is_special=True)
    KEYCODES[-67] = KeyCode(name="RIGHT", is_special=True)
    KEYCODES[-68] = KeyCode(name="LEFT", is_special=True)

    CANCEL_KEYCODES_NAMES = set(["ESC", "FS", "CTRL-C"])
    # }}}3

    class OutOfWindowBoundsException(Exception):
        pass

    @staticmethod
    def get_console_dimensions():
        env = os.environ
        def ioctl_GWINSZ(fd):
            try:
                cr = struct.unpack('hh', fcntl.ioctl(fd, termios.TIOCGWINSZ, '1234'))
            except:
                return
            return cr
        return ioctl_GWINSZ(0) or ioctl_GWINSZ(1) or ioctl_GWINSZ(2) or (25, 80)

    @staticmethod
    def stop():
        curses.echo()
        curses.endwin()

    ### Life-cycle

    def __init__(self, stdscr, nrows=None):
        self.stdscr = stdscr
        self.is_input_blocking = None
        self.content_pad = None
        self.content_vscroll_offset = 0
        self._is_input_blocking = None
        self.start(nrows=nrows)
        self.query_length = 0
        self.content_limit = 1000
        self.content_items = None

    def start(self, nrows=None):
        cv_height, cv_width = self.content_pad_available_display_dimensions()
        if nrows is None:
            nrows = cv_height
        self.content_pad = curses.newpad(nrows, cv_width)

        curses.use_default_colors()

        curses.init_pair(1, -1, -1)
        self.default_color = curses.color_pair(1)

        curses.init_pair(2, curses.COLOR_GREEN, -1)
        self.match_color = curses.color_pair(2) | curses.A_UNDERLINE

        curses.init_pair(3, curses.COLOR_MAGENTA, -1)
        self.is_selected_color = curses.color_pair(3) | curses.A_BOLD

        curses.init_pair(4, -1, -1)
        self.current_row_color = curses.color_pair(4) # note: will be reversed below

        curses.init_pair(5, curses.COLOR_MAGENTA, -1)
        self.prompt_color = curses.color_pair(5) | curses.A_BOLD

        curses.init_pair(6, curses.COLOR_GREEN, curses.COLOR_BLACK)
        self.status_bar_color = curses.color_pair(6) | curses.A_BOLD | curses.A_REVERSE

        curses.init_pair(7, curses.COLOR_YELLOW, curses.COLOR_BLACK)
        self.spinner_color = curses.color_pair(7) | curses.A_BOLD | curses.A_REVERSE

        curses.init_pair(8, curses.COLOR_YELLOW, curses.COLOR_RED)
        self.error_color = curses.color_pair(8) | curses.A_BOLD | curses.A_REVERSE

        self.is_input_blocking = False

    def restart(self):
        # self.stdscr.refresh()
        self.refresh()

    ### Book-keeping

    def screen_dimensions(self):
        return self.stdscr.getmaxyx()

    def content_pad_dimensions(self):
        return self.content_pad.getmaxyx()

    def content_pad_available_display_dimensions(self):
        screen_height, screen_width = self.screen_dimensions()
        return screen_height - 3, screen_width

    def resize_content_pad(self, nrows):
        self.content_pad.resize(nrows, self.screen_dimensions()[1])

    def _get_input_blocking(self):
        return self._is_input_blocking
    def _set_input_blocking(self, is_blocking):
        self._is_input_blocking = is_blocking
        if self._is_input_blocking:
            self.stdscr.nodelay(0)
        else:
            self.stdscr.nodelay(1)
    is_input_blocking = property(_get_input_blocking, _set_input_blocking)

    def set_cursor(self, value):
        if value is None:
            return
        try:
            return curses.curs_set(value)
        except:
            pass

    ### Rendering (Framework)

    def error(self, message, erase=True):
        if erase:
            self.content_pad.erase()
        height, width = self.screen_dimensions()
        self.write_status_bar(message, self.error_color, refresh=True)
        self.stdscr.move(height - self.STATUS_BAR_OFFSET, min(len(message), self.screen_dimensions()[1]-1))
        self.pause_for_keypress()

    def write_status_bar(self, s, color=None, refresh=True):
        if color is None:
            color = self.status_bar_color
        height, width = self.screen_dimensions()
        # self.stdscr.clrtoeol()
        padded_message = s.ljust(width-1)[:width-1]
        self.stdscr.addstr(height - self.STATUS_BAR_OFFSET, 0, padded_message, color)
        if refresh:
            self.stdscr.refresh()

    ### Rendering (Content)

    def render_main(self,
            heap,
            focal_item_index,
            query_str,
            match_type,
            whole_path_matching,
            search_path_info=None,
            ):
        self.stdscr.erase()
        self.render_content_items(heap, focal_item_index)
        self.render_query(
                query_str=query_str,
                match_type=match_type,
                whole_path_matching=whole_path_matching,
                focal_item_index=focal_item_index,
                search_path_info=search_path_info)
        self.refresh(focal_item_index=focal_item_index)
        return self.content_items

    def render_content_items(self, heap, focal_item_index):
        self.content_pad.erase()
        self.content_items = []
        if heap:
            if len(heap) > self.content_pad_dimensions()[0]:
                self.resize_content_pad(len(heap))
            hc = list(heap)
            current_index = 0
            while hc:
                score, item, match_start, match_end = heapq.heappop(hc)
                self.content_items.append(item)
                try:
                    self.render_content_item(current_index, item, current_index==focal_item_index)
                except Display.OutOfWindowBoundsException:
                    break
                current_index += 1
        return self.content_items

    def render_content_item(self,
            item_index,
            item,
            is_focal_item):
        height, width = self.content_pad_dimensions()
        row = height - item_index - 1
        if row < 0:
            raise Display.OutOfWindowBoundsException
        # self.content_pad.move(row, 0)
        # self.content_pad.clrtoeol()
        # -4: account for leader, and avoid writing at last position
        display_name = truncate_middle(item.display_name, width-4).ljust(width-4)
        weight = curses.A_NORMAL
        color = self.default_color
        if item.is_selected:
            self.content_pad.addstr(row, 0, "#", self.is_selected_color | curses.A_BOLD)
            color = self.is_selected_color
        else:
            self.content_pad.addstr(row, 0, " ", self.default_color)
        if is_focal_item:
            self.content_pad.addstr(row, 1, "> ", self.default_color)
            color = self.current_row_color
            # to reverse all parts of the line (included matched)
            weight = curses.A_REVERSE
        else:
            self.content_pad.addstr(row, 1, "  ", self.default_color)
        if item.score > 0:
            left = display_name[:item.match_start]
            main = display_name[item.match_start:item.match_end]
            right = display_name[item.match_end:]
            self.content_pad.addstr(row, 3, left, color | weight)
            self.content_pad.addstr(row, 3 + len(left), main, self.match_color | weight)
            self.content_pad.addstr(row, 3 + len(left) + len(main), right, color | weight)
        else:
            self.content_pad.addstr(row, 3, display_name, color | weight)

    def render_query(self,
            query_str,
            match_type,
            whole_path_matching,
            focal_item_index,
            search_path_info=None,
            ):
        height, width = self.screen_dimensions()
        status_bar_components = []
        if match_type == "fuzzy":
            prompt = "? "
            status_bar_components.append("[^E] expression: fuzzy  ")
        elif match_type == "literal":
            prompt = "= "
            status_bar_components.append("[^E] expression: literal")
        elif match_type == "regexp":
            prompt = "% "
            status_bar_components.append("[^E] expression: regular")
        if whole_path_matching:
            status_bar_components.append("[^W] match: whole path")
        else:
            status_bar_components.append("[^W] match: basename")
        status_bar = " ".join(status_bar_components)
        if search_path_info is None:
            search_path_info = ""
        if search_path_info:
            remaining = width - len(status_bar) - 1
            if remaining > 0:
                status_bar += (("({})".format(truncate_front(search_path_info, remaining))).rjust(remaining))
                # num_entries = len(self.content_items)
                # if num_entries:
                #     focal_item_index += 1
                # status_bar += ("{} of {} entries (".format(focal_item_index, num_entries, truncate_front(search_path_info, remaining).rjust(remaining)
        status_bar = status_bar.ljust(width-1)[:width-1]
        self.stdscr.addstr(height - self.STATUS_BAR_OFFSET, 0, status_bar, self.status_bar_color)
        q = prompt + query_str
        self.query_length = len(q)
        self.stdscr.addstr(height - self.QUERY_ROW_OFFSET, 0, q, self.prompt_color)

    ### Displaying

    def clear(self):
        self.stdscr.erase()

    def clear_content(self):
        self.content_pad.erase()

    def refresh(self, focal_item_index):
        try:
            content_height, content_width = self.content_pad_dimensions()
            screen_height, screen_width = self.screen_dimensions()
            self.stdscr.noutrefresh()
            num_content_items = len(self.content_items)
            if not num_content_items:
                self.content_pad.noutrefresh(
                        0,
                        0,
                        0,
                        0,
                        screen_height-3,
                        screen_width,
                        )
            else:
                available_height = self.content_pad_available_display_dimensions()[0]
                if num_content_items < available_height:
                    screen_top = screen_height - num_content_items - 2
                    content_top = content_height - num_content_items
                else:
                    screen_top = 0
                    half_available_height = int(available_height / 2)
                    if focal_item_index < half_available_height:
                        # bottom
                        content_top = content_height - available_height - 1
                    elif focal_item_index + half_available_height >= num_content_items:
                        # top
                        content_top = content_height - num_content_items
                    else:
                        # middle
                        current_item_row = content_height - focal_item_index
                        content_top = current_item_row - half_available_height - 1
                self.content_pad.noutrefresh(
                        content_top,
                        0,
                        screen_top,
                        0,
                        screen_height-3,
                        screen_width,
                        )
            curses.doupdate()
        except Exception as e:
            raise

    ### Input

    def getch(self, blocking=None, echo=None):
        # set state
        self.is_input_blocking = blocking
        if echo is False:
            curses.noecho()
        elif echo is True:
            curses.echo()
        ch = self.stdscr.getch()
        ### FOLLOWING HACK NOT NEEDED ANY MORE, DUE TO FOLLOWING APPROACH::
        ###
        ###    with os.fdopen(0, 'r') as src:
        ###       for item in src.read().split("\n"):
        ###            # do stuff!
        ###    sys.stdin = open("/dev/tty", "r")
        ###
        # if blocking and ch == -1:
        #     # We are here because files were read from standard input
        #     # and now input is unavailable. This hack works on POSIX
        #     # systems ... but ARROW keys lead to exit in the loop
        #     # because we checking for escape (by itself) in a non-blocking
        #     # way.
        #     import tty
        #     fd = sys.stdin.fileno()
        #     tty_mode = tty.tcgetattr(fd)
        #     tty.setcbreak(fd)
        #     try:
        #         ch = ord(os.read(fd, 1))
        #     finally:
        #         tty.tcsetattr(fd, tty.TCSAFLUSH, tty_mode)
        #     assert isinstance(ch, int)

        # restore state
        if blocking:
            self.is_input_blocking = False
        if echo:
            curses.noecho()
        return ch

    def get_keycode(self, blocking=True, echo=False):
        ch_value = self.getch(blocking=blocking, echo=echo)
        if ch_value == -1:
            return None
        elif ch_value == 27:
            # Escape: could be just Escape, could be Ansi escape for
            # arrows
            # just escape? try non-blocking read to see if
            # any other characters
            ch_value = self.getch(blocking=False, echo=echo)
            if ch_value == -1:
                # Nope: just escape
                return self.KEYCODES[27]
            # other characters available
            # assuming arrow-key, we discard
            # the current and read the next
            ch_value = self.getch(blocking=True, echo=echo)
            return self.KEYCODES.get(-ch_value, None) # None if not handled
        else:
            return self.KEYCODES.get(ch_value, None)

    def get_query_keycode(self, echo=False):
        height, width = self.screen_dimensions()
        self.stdscr.move(height - self.QUERY_ROW_OFFSET, self.query_length)
        cursor = self.set_cursor(2)
        keycode = self.get_keycode(blocking=True, echo=echo)
        cursor = self.set_cursor(cursor)
        return keycode

    def pause_for_keypress(self):
        cursor = self.set_cursor(2)
        ch = self.getch(blocking=True)
        self.set_cursor(cursor)
        return ch

    def check_for_cancel(self):
        keycode = self.get_keycode(blocking=False, echo=False)
        if keycode is not None and keycode.name in self.CANCEL_KEYCODES_NAMES:
            return True
        return False

    ### Content Interaction

    # Does not work: heap is not stable for random access.
    # So need to
    #   (a) make copy of list, pop off till we reach respective indices, TWICE
    #   (b) cache items in list somewhere
    #   (c) rebuild entire screen
    #   ... for now, opting for last
    def update_focal_item(self, current_focal_item_index, new_focal_item_index):
        if new_focal_item_index != current_focal_item_index:
            # try:
            #     self.render_content_item(current_focal_item_index, self.content_items[current_focal_item_index][1], False)
            # except Display.OutOfWindowBoundsException:
            #     pass
            # try:
            #     self.render_content_item(new_focal_item_index, self.content_items[new_focal_item_index][1], True)
            # except Display.OutOfWindowBoundsException:
            #     pass
            self.render_content_item(current_focal_item_index, self.content_items[current_focal_item_index], False)
            self.render_content_item(new_focal_item_index, self.content_items[new_focal_item_index], True)
            self.refresh(new_focal_item_index)

    def move_focus_to_next(self, focal_item_index, count=1):
        # Since we display from the bottom up, moving 'down' or 'next' means
        # moving to a *higher*-scoring result, which requires *decrement* the
        # index to move *up* the list, which is sorted incrementally by score.
        new_item_index = max(0, focal_item_index - count)
        self.update_focal_item(focal_item_index, new_item_index)
        return new_item_index

    def move_focus_to_previous(self, focal_item_index, count=1):
        # Since we display from the bottom up, moving 'up' or 'previous' means
        # moving to a *lower*-ring result, which requires *incrementing* the
        # index to move *down* the list, which is sorted incrementally by score.
        new_item_index = min(len(self.content_items)-1, focal_item_index + count)
        # new_item_index = focal_item_index + 1
        if new_item_index < 0:
            new_item_index = 0
        self.update_focal_item(focal_item_index, new_item_index)
        return new_item_index

    def page_down(self, focal_item_index):
        available_height = self.content_pad_available_display_dimensions()[0]
        return self.move_focus_to_next(focal_item_index, available_height)

    def page_up(self, focal_item_index):
        available_height = self.content_pad_available_display_dimensions()[0]
        return self.move_focus_to_previous(focal_item_index, available_height)

    ### Special

    def get_progress_ticker(self):
        return ProgressTicker(display=self, color=self.spinner_color)

# }}}2

class ProgressTicker(object): # {{{2

    def __init__(self, display, color):
        self.display = display
        self.color = color
        self.current_step = 0
        self.spinner_cycle = itertools.cycle(["|", "/", "-", "\\", "-",])

    def update(self, message):
        self.current_step += 1
        s0 = next(self.spinner_cycle) + " " + message
        self.display.write_status_bar(s0, color=self.color, refresh=True)

        # height, width = get_screen_dimensions()
        # # self.window.addstr("[" + next(self.spinner_cycle) + "] " + message)
        # self.window.move(height - STATUS_BAR_OFFSET, 0)
        # self.window.addstr(s1, self.spinner_color)
        # self.window.move(height - STATUS_BAR_OFFSET, min(len(s0), width-1))
        # self.window.refresh()

# }}}2


# }}}1

# Debugging {{{1
# ==============================================================================
def dump_stack(out=None):
    import inspect
    if out is None:
        out = sys.stderr
    for frame, filename, line_num, func, source_code, source_index in inspect.stack()[2:]:
        if source_code is None:
            out.write("{}: {}\n".format(filename, line_num))
        else:
            out.write("{}: {}: {}\n".format(filename, line_num, source_code[source_index].strip()))
# }}}1

# External Command and Event Handling {{{1
# ==============================================================================

def compose_command(cmd,
        args=None,
        substitute_token="{}"):
    cmd = shlex.split(cmd)
    if args is not None:
        substitution_made = False
        prev_idx = 0
        expanded_cmd = []
        for idx, token in enumerate(cmd):
            if token == substitute_token:
                expanded_cmd.extend(cmd[prev_idx:idx])
                expanded_cmd.extend(args)
                prev_idx = idx + 1
                substitution_made = True
        if not substitution_made:
            cmd.extend(args)
        else:
            cmd = expanded_cmd + cmd[prev_idx:]
    return cmd

def execute_command(cmd,
        args=None,
        substitute_token="{}",
        verbose=True,
        as_subprocess=False):
    cmd = compose_command(
            cmd=cmd,
            args=args,
            substitute_token=substitute_token)
    if verbose:
        sys.stderr.write("{}\n".format(" ".join(cmd)))
    try:
        if not as_subprocess:
            # Note: cannot use subprocess here due to parent process (this program)
            # needing to exit before the subprocess is possibly done. `os.exec` and
            # its kin work: independent processed is spawned and the current
            # process is replaced by it.
            os.execvp(cmd[0], cmd)
        else:
            p = subprocess.Popen(cmd)
            p.communicate()
    except OSError:
        sys.stderr.write("Failed to execute command with tokens: {}\n".format(cmd))
        sys.exit(1)

# }}}1

# Data Model {{{1
# ==============================================================================

class Entry(object):

    def __init__(self,
            dirname,
            filename,
            score,
            match_start,
            match_end,
            whole_path_matching,
            is_selected=False):
        self._dirname = os.path.normpath(dirname)
        self._filename = os.path.normpath(filename)
        # self.dirname = dirname
        # self.filename = filename
        self.score = score
        self.whole_path_matching = whole_path_matching
        self._match_start_offset = match_start
        self._match_end_offset = match_end
        self.is_selected = is_selected

    def _get_match_target(self):
        if self.whole_path_matching:
            return self.filepath
        else:
            return self.filename
    match_target = property(_get_match_target)

    def _get_display_name(self):
        return self.filepath
    display_name = property(_get_display_name)

    def _get_dirname(self):
        return self._dirname
    def _set_dirname(self, name):
        if name:
            self._dirname = os.path.normpath(name)
        else:
            self._dirname = ""
    dirname = property(_get_dirname, _set_dirname)

    def _get_filename(self):
        return self._filename
    def _set_filename(self, name):
        if name:
            self._filename = os.path.normpath(name)
        else:
            self._filename = ""
    filename = property(_get_filename, _set_filename)

    def _get_filepath(self):
        return os.path.normpath(os.path.join(self._dirname, self._filename))
    filepath = property(_get_filepath)

    def _start_of_basename_in_filepath(self):
        return len(os.path.normpath(os.path.join(self._dirname, "x"))) - 1

    def _get_match_start(self):
        if self.whole_path_matching:
            return self._match_start_offset
        else:
            return self._start_of_basename_in_filepath() + self._match_start_offset
    def _set_match_start(self, v):
        self._match_start_offset = v
    match_start = property(_get_match_start, _set_match_start)

    def _get_match_end(self):
        if self.whole_path_matching:
            return self._match_end_offset
        else:
            return self._start_of_basename_in_filepath() + self._match_end_offset
    def _set_match_end(self, v):
        self._match_end_offset = v
    match_end = property(_get_match_end, _set_match_end)

    def __lt__(self, other):
        return self.score < other.score

# }}}1

# Controllers {{{1
# ==============================================================================

class Selector(object): # {{{2

    class ResetSourcesException(Exception):
        def __init__(self, items):
            self.items = items

    def __init__(self,
            display,
            ranker,
            whole_path_matching=False,
            match_type="fuzzy",
            multiselection_mode=True,
            path_up_fn=None,
            path_down_fn=None,
            search_path_info=None,
            ):
        self.display = display
        self.ranker = ranker
        self.whole_path_matching = whole_path_matching
        self.match_type = match_type
        self.multiselection_mode = multiselection_mode
        self.path_up_fn = path_up_fn
        self.path_down_fn = path_down_fn
        self.search_path_info = search_path_info

    def _new_heap(self, query_chars, cur_heap):
        new_heap = []
        ranker = self.ranker(
                query_str="".join(query_chars),
                whole_path_matching=self.whole_path_matching,
                match_type=self.match_type)
        for w, item, ms, me in cur_heap:
            item.whole_path_matching = self.whole_path_matching # needs to be updated here
            try:
                score, match_start, match_end = ranker.rank(item)
            except FuzzyRanker.IncompleteRegularExpressionPatternException:
                return cur_heap
            if score:
                item.score = score
                item.match_start = match_start
                item.match_end = match_end
                heapq.heappush(new_heap, (score, item, match_start, match_end))
            else:
                item.score = 0
                item.match_start = 0
                item.match_end = 0
                item.is_selected = False
        return new_heap

    def _reset_current_search(self, current_query_chars, current_heaps):
        current_heaps = current_heaps[:1]
        old_query_chars = current_query_chars
        current_query_chars = []
        for ch in old_query_chars:
            current_query_chars.append(ch)
            current_heaps.append(self._new_heap(current_query_chars, current_heaps[-1]))
        return current_heaps

    def _loop(self, current_heaps, display_items):
        heapq.heapify(current_heaps[0])
        current_query_chars = []
        focal_item_index = 0
        while True:
            # self.output.window.timeout(-1)
            # keycode = self.display.get_keycode(blocking=True, echo=False)
            keycode = self.display.get_query_keycode(echo=False)

            if keycode is None:
                continue
            if keycode.name == "ESC":
                raise KeyboardInterrupt
            elif keycode.name == "UP" or keycode.name == "CTRL-P":
                focal_item_index = self.display.move_focus_to_previous(focal_item_index)
            elif keycode.name == "DOWN" or keycode.name == "CTRL-N":
                focal_item_index = self.display.move_focus_to_next(focal_item_index)
            elif keycode.name == "CTRL-B":
                focal_item_index = self.display.page_up(focal_item_index)
            elif keycode.name == "CTRL-F":
                focal_item_index = self.display.page_down(focal_item_index)
            elif keycode.name == "LEFT" or keycode.name == "CTRL-U":
                if self.path_up_fn:
                    items, search_path_info = self.path_up_fn()
                    if items is not None:
                        self.search_path_info = search_path_info
                        raise Selector.ResetSourcesException(items=items)
            elif keycode.name == "RIGHT" or keycode.name == "CTRL-D":
                if self.path_down_fn and display_items and focal_item_index < len(display_items):
                    focal_item = display_items[focal_item_index]
                    selected_items = self._extract_selected_from_display_items(
                            display_items=display_items,
                            focal_item_index=focal_item_index)
                    items, search_path_info = self.path_down_fn(focal_item=focal_item,
                            selected_items=selected_items)
                    if items is not None:
                        self.search_path_info = search_path_info
                        raise Selector.ResetSourcesException(items=items)
            else:
                # following all require full re-rendering
                suppress_rerender = False
                if keycode.name == "CTRL-W":
                    # <CTRL-W>: Cycle whole-path vs. basename matching
                    self.whole_path_matching = not self.whole_path_matching
                    current_heaps = self._reset_current_search(current_query_chars, current_heaps)
                elif keycode.name == "CTRL-E":
                    # <CTRL-R>: Cycle matching-modes
                    if self.match_type == "literal":
                        self.match_type = "regexp"
                    elif self.match_type == "fuzzy":
                        self.match_type = "literal"
                    else:
                        self.match_type = "fuzzy"
                    current_heaps = self._reset_current_search(current_query_chars, current_heaps)
                # elif keycode.name == "CTRL-F":
                #     # <CTRL-F>: Fuzzy-matching mode
                #     self.match_type = "fuzzy"
                #     current_heaps = self._reset_current_search(current_query_chars, current_heaps)
                # elif keycode.name == "CTRL-E":
                #     # <CTRL-E>: Regular-expression matching mode
                #     self.match_type = "regexp"
                #     current_heaps = self._reset_current_search(current_query_chars, current_heaps)
                # elif keycode.name == "CTRL-L":
                #     # <CTRL-L>: Literal or raw matching mode
                #     self.match_type = "literal"
                #     current_heaps = self._reset_current_search(current_query_chars, current_heaps)
                # # elif keycode.name == "CTRL-W":
                # #     # <CTRL-W>: Toggle whitespace-separated multi-search
                # elif keycode.name == "CTRL-T":
                #     # <CTRL-T>: Toggle whitespace-separated multi-term query
                #     self.whitespace_separated_multiquery = not self.whitespace_separated_multiquery
                #     current_heaps = self._reset_current_search(current_query_chars, current_heaps)
                elif keycode.name == "CTRL-I":
                    # <TAB>: toggle in multiselection mode; simply consume character otherwise
                    if self.multiselection_mode:
                        display_items[focal_item_index].is_selected = not display_items[focal_item_index].is_selected
                elif keycode.name == "CTRL-X":
                    # <CTRL-X>: Cancel all in multiselection mode; simply consume character otherwise
                    if self.multiselection_mode:
                        # for w, item, ms, me in current_heaps[-1]:
                        for item in display_items:
                            item.is_selected = False
                elif keycode.name == "CTRL-A":
                    # <CTRL-A>: Mark all in multiselection mode; simply consume character otherwise
                    if self.multiselection_mode:
                        # for w, item, ms, me in current_heaps[-1]:
                        for item in display_items:
                            item.is_selected = True
                elif keycode.name == "CTRL-G":
                    # <CTRL-G>: Invert selection
                    if self.multiselection_mode:
                        # for w, item, ms, me in current_heaps[-1]:
                        for item in display_items:
                            item.is_selected = not item.is_selected
                elif keycode.name == "CTRL-J" or keycode.name == "CTRL-M":
                    if display_items and focal_item_index <= len(display_items):
                        return self._extract_selected_from_display_items(
                                display_items=display_items,
                                focal_item_index=focal_item_index)
                    else:
                        suppress_rerender = True
                elif keycode.name == "CTRL-H" or keycode.name == "DEL":
                    # Delete/backspace
                    if current_query_chars:
                        current_query_chars.pop()
                        current_heaps.pop()
                        # restore match boundaries
                        try:
                            for score, item, match_start, match_end in current_heaps[-1]:
                                # ensure same search regime, so saved search can be reused
                                assert item.whole_path_matching is self.whole_path_matching
                                item.score = score
                                item.match_start = match_start
                                item.match_end = match_end
                        except AssertionError:
                            # different search regime: need to rebuild old heap
                            current_heaps.pop()
                            current_heaps.append(self._new_heap(current_query_chars, current_heaps[-1]))
                        focal_item_index = 0 # TODO: adjust this smartly
                elif not keycode.is_special:
                    # normal char
                    # try:
                    #     current_query_chars.append(keycode.name)
                    #     current_heaps.append(self._new_heap(current_query_chars, current_heaps[-1]))
                    #     focal_item_index = 0 # TODO: adjust this smartly
                    # except ValueError:
                    #     pass
                    current_query_chars.append(keycode.name)
                    current_heaps.append(self._new_heap(current_query_chars, current_heaps[-1]))
                    focal_item_index = 0 # TODO: adjust this smartly
                else:
                    # not supported
                    suppress_rerender = True
                if not suppress_rerender:
                    display_items = self.render(
                            heap=current_heaps[-1],
                            focal_item_index=focal_item_index,
                            query_chars=current_query_chars,
                            )

    def _extract_selected_from_display_items(self, display_items, focal_item_index):
        if display_items and focal_item_index <= len(display_items):
            if self.multiselection_mode:
                display_items[focal_item_index].is_selected = True
                return [item for item in display_items if item.is_selected]
            else:
                return [display_items[focal_item_index]]
        else:
            return []

    # def _extract_selected_from_heap(self, heap, focal_item_index):
    #     if self.multiselection_mode:
    #         return self._extract_multiselected_from_heap(
    #                 heap=heap,
    #                 focal_item_index=focal_item_index)
    #     else:
    #         return self._extract_focal_item_from_heap(
    #                 heap=heap,
    #                 focal_item_index=focal_item_index)

    # def _extract_multiselected_from_heap(self, heap, focal_item_index):
    #     selected_items = []
    #     index = 0
    #     while heap:
    #         score, item, match_start, match_end = heapq.heappop(heap)
    #         if item.is_selected or index == focal_item_index:
    #             selected_items.append(item)
    #         index += 1
    #     return selected_items

    # def _extract_focal_item_from_heap(self, heap, focal_item_index):
    #     # return [heap[focal_item_index][1]]
    #     while focal_item_index:
    #         if not heap:
    #             break
    #         heapq.heappop(heap)
    #         focal_item_index -= 1
    #     return [heap[0][1]] if heap else []

    def render(self, heap, focal_item_index, query_chars):
        return self.display.render_main(
                heap=heap,
                focal_item_index=focal_item_index,
                query_str="".join(query_chars),
                match_type=self.match_type,
                whole_path_matching=self.whole_path_matching,
                search_path_info=self.search_path_info,
                )

    def run(self, items):
        while True:
            try:
                # heap = [(i.score, i, i.match_start, i.match_end) for i in items]
                heap = [(i.score, i, 0, 0) for i in items]
                heap.sort()
                display_items = self.render(
                        heap=heap,
                        focal_item_index=0,
                        query_chars=[],
                        )
                return self._loop([heap], display_items)
            except Selector.ResetSourcesException as e:
                items = e.items
# }}}2

class DirectorySource(object): # {{{2

    dot_dirs_ignore_pattern = None

    def __init__(self,
            display,
            target_filename_patterns=None,
            ignore_directories=True,
            ignore_files=True,
            respect_gitignores=True,
            include_hidden=False,
            dirs_to_exclude=None,
            files_to_exclude=None,
            filter_for_glob_names=None,
            max_recursion_depth=None):
        self.display = display
        self.ignore_directories = ignore_directories
        self.ignore_files = ignore_files
        self.respect_gitignores = respect_gitignores
        if target_filename_patterns is None:
            self.target_filename_pattern = None
        else:
            self.target_filename_pattern = re.compile("(" + "|".join(target_filename_patterns) + ")")
        self.include_hidden = include_hidden
        if not self.include_hidden:
            # hidden_dir_pattern = r".*{s}\.[^{s}]".format(s=os.path.sep)
            # hidden_dir_pattern = r"^.*{s}\.[^.{s}][^{s}]+$".format(s=os.path.sep)
            # hidden_dir_pattern = r"^\.[^.{s}]".format(s=os.path.sep)
            # hidden_dir_pattern = r"{s}\.[^.]".format(s=os.path.sep)
            # hidden_dir_pattern = r"^\./\.cac".format(s=os.path.sep)
            hidden_dir_pattern = r"(^(\.{s})?\.[^.{s}]|{s}\.[^.])".format(s=os.path.sep)
            try:
                dirs_to_exclude.append(hidden_dir_pattern)
            except AttributeError:
                dirs_to_exclude = [hidden_dir_pattern]
            hidden_file_pattern = r"^\."
            try:
                files_to_exclude.append(hidden_file_pattern)
            except AttributeError:
                files_to_exclude = [hidden_file_pattern]
        if dirs_to_exclude is None:
            self.dirs_to_exclude = None
        else:
            self.dirs_to_exclude = re.compile("(" + "|".join(dirs_to_exclude) + ")")
        if files_to_exclude is None:
            self.files_to_exclude = None
        else:
            self.files_to_exclude = re.compile("(" + "|".join(files_to_exclude) + ")")
        if filter_for_glob_names is None:
            self.filter_for_glob_names = None
        else:
            self.filter_for_glob_names = filter_for_glob_names
        if DirectorySource.dot_dirs_ignore_pattern is None:
            dot_dirs_to_ignore = ["git", "svn", "hg"]
            dot_dirs_to_ignore = ["(.*/|)\.{}".format(d) for d in dot_dirs_to_ignore]
            dot_dirs_ignore_pattern = "(" + "|".join(dot_dirs_to_ignore) + ")"
            DirectorySource.dot_dirs_ignore_pattern = re.compile(dot_dirs_ignore_pattern)
        self.max_recursion_depth = max_recursion_depth
        self.filters = []
        self.git_exclude_filters = []

    def recurse_directory_up(self, dirname):
        if os.path.isdir(dirname):
            while True:
                yield dirname
                newdir = os.path.dirname(dirname)
                if not newdir or newdir == dirname:
                    break
                dirname = newdir

    def find_parent_gis(self, start_dir):
        dirs = self.recurse_directory_up(start_dir)
        for dirname in dirs:
            if dirname == start_dir:
                continue
            pgi = os.path.join(dirname, '.gitignore')
            if os.path.isfile(pgi):
                self.filters.append((dirname, GitIgnoreFilter(dirname, '.gitignore')))
        self.filters.reverse()
        return self.filters

    def fetch(self,
            start_dir=".",
            results=None,
            suppress_progress_feedback=False):
        self.filters = []
        self.git_exclude_filters = []
        if self.respect_gitignores:
            self.find_parent_gis(start_dir)
        if results is None:
            results = []
        progress = self.display.get_progress_ticker()
        total_items_scanned = 0
        for search_idx, (dirname, dirs, filenames) in enumerate(walk(start_dir)):
            if self.display.check_for_cancel():
                raise KeyboardInterrupt()
            # dirname = os.path.normpath(dirname)
            total_items_scanned += (1 + len(dirs) + len(filenames))
            if search_idx % 100 == 0:
                progress.update("Scanning: found {} out of {} names".format(len(results), total_items_scanned))
            if self.max_recursion_depth is not None:
                recursion_level = dirname.count(os.path.sep)
                if recursion_level == self.max_recursion_depth:
                    del dirs[:]
                elif recursion_level > self.max_recursion_depth:
                    continue
            if self.respect_gitignores and ".git" in dirs:
                giexclude = os.path.join('.git', 'info', 'exclude')
                if os.path.isfile(os.path.join(dirname, giexclude)):
                    gief = GitIgnoreFilter(dirname, giexclude)
                    self.git_exclude_filters.append(gief)
            if DirectorySource.dot_dirs_ignore_pattern.match(dirname):
                continue
            if self.dirs_to_exclude is not None and self.dirs_to_exclude.match(dirname):
                continue
            names = []
            if not self.ignore_files:
                for f in filenames:
                    if ((self.files_to_exclude is None or not self.files_to_exclude.match(f))
                            and (self.target_filename_pattern is None or self.target_filename_pattern.match(f))
                            and (self.filter_for_glob_names is None or any(fnmatch.fnmatch(f, gf) for gf in self.filter_for_glob_names))
                            ):
                        # if self.paths_to_exclude is not None:
                        #     # only do this if actual paths to exclude
                        #     ff = os.path.join(dirname, f)
                        #     if not self.paths_to_exclude.match(f):
                        #         names.append(f)
                        # else:
                        #     names.append(f)
                        names.append(f)
            if not self.ignore_directories:
                for candidate_dir in dirs:
                    if ((not DirectorySource.dot_dirs_ignore_pattern.match(candidate_dir))
                            and (self.dirs_to_exclude is None or not self.dirs_to_exclude.match(candidate_dir))
                            and (self.filter_for_glob_names is None or all(fnmatch.fnmatch(candidate_dir, gf) for gf in self.filter_for_glob_names))
                            ):
                        names.append(candidate_dir)
            if self.respect_gitignores and '.gitignore' in filenames:
                gif = GitIgnoreFilter(dirname, '.gitignore', self.git_exclude_filters)
                self.filters.append((dirname, gif))
            while self.filters: # find filter that applies to current path
                path, filter_obj = self.filters[-1]
                if dirname.startswith(path):
                    break
                self.filters.pop()
            fltr = None
            if self.filters:
                fltr = self.filters[-1][1] # grab filter object of last filter entry
            for name in names:
                if fltr is None or fltr(name, dirname):
                    entry = Entry(dirname=dirname,
                            filename=name,
                            score=len(results),
                            match_start=0,
                            match_end=0,
                            whole_path_matching=False)
                    results.append(entry)
            # have to delete the names manually
            if fltr is not None:
                for i in range(len(dirs) - 1, -1, -1):
                    if not fltr(dirs[i], dirname):
                        del dirs[i]
        return results
# }}}2

class GitIgnoreFilter(object): # {{{2
    # Optimization
    lastdir = None
    last_path_filter = None

    globchars = re.compile('[*\[\]?]')
    def __init__(self,
            dirname,
            filename,
            inherited_filters=None):
        self.dirname = dirname
        self.fn = os.path.join(dirname, filename)
        path_filters = []
        glob_filters = []
        exact_filters = set(['.git'])
        with open(self.fn) as f:
            gc = self.globchars
            for fn in f:
                if fn.startswith('#'):
                    continue
                fn = fn.strip()
                if fn.startswith('/') or fn.endswith('/'):
                    path_filters.append(fn)
                elif gc.search(fn) is not None:
                    glob_filters.append(fn)
                else:
                    exact_filters.add(fn)
        if glob_filters:
            self.glob_filters = glob_filters
        else:
            self.glob_filters = []
        self.exact_filters = exact_filters
        self.path_filters = self.setup_path_filters(path_filters)
        if inherited_filters is not None:
            for f in inherited_filters:
                self.glob_filters.extend(f.glob_filters)
                self.exact_filters.update(f.exact_filters)
                for k in f.path_filters:
                    try:
                        self.path_filters[k].extend(f.path_filters[k])
                    except KeyError:
                        self.path_filters[k] = list(f.path_filters[k])

    def setup_path_filters(self, path_filters):
        dirmaps = {}
        for pf in path_filters:
            pf = pf.rstrip("/")
            dirname, basename = os.path.split(pf)
            dm = os.path.join(self.dirname, dirname.lstrip("/")).rstrip("/")
            glob = basename.strip()
            if dm in dirmaps:
                dirmaps[dm].append(glob)
            else:
                dirmaps[dm] = [glob]
        return dirmaps

    def __call__(self, fn, dirname):
        # check exact
        if fn in self.exact_filters:
            return False
        # Check global globs
        for f in self.glob_filters:
            # yes, this block is ugly and horribly inefficient
            # better approach needed, probably by using reg-ex
            full_path = os.path.join(dirname, fn)
            if fnmatch.fnmatch(full_path, f):
                return False
            if fnmatch.fnmatch(fn, f):
                return False
            if fnmatch.fnmatch(os.path.normpath(full_path), f):
                return False
            if fnmatch.fnmatch(os.path.normpath(fn), f):
                return False
        lpf = self.path_filters.get(dirname)
        # check path dependent globs
        if lpf is not None:
            for f in lpf:
                if fnmatch.fnmatch(fn, f):
                    return False
        return True
# }}}2

class FuzzyRanker(object): # {{{2

    class IncompleteRegularExpressionPatternException(Exception):
        pass

    def match_and_score(query_str, target_str, match_type):
        if match_type == "fuzzy":
            pattern = '.*?'.join(map(re.escape, list(query_str)))
        elif match_type == "literal":
            pattern = ''.join(map(re.escape, list(query_str)))
        elif match_type == "regexp":
            pattern = query_str
        else:
            raise TypeError("Unrecognized pattern type: '{}'".format(match_type))
        try:
            match = re.search(pattern, target_str, re.I)
        except re.error:
            if match_type == "regexp":
                raise FuzzyRanker.IncompleteRegularExpressionPatternException()
        if match is None:
            result = 0
        else:
            # result = 100.0 / ((1+match.start()) * (match.end()-match.start()+1))
            result = ((1 + match.start()) * (match.end() - match.start() + 1)) / 1000.0
            # if match_type == "fuzzy":
            #     result = (1+levenshtein(target_str, query_str))
            # else:
            #     result = ((1 + match.start()) * (match.end() - match.start() + 1)) / 1000.0
        return match, result
    match_and_score = staticmethod(match_and_score)

    def __init__(self,
            query_str,
            whole_path_matching=False,
            match_type="fuzzy"):
        self.whole_path_matching = whole_path_matching
        self.weight_f = lambda f: f.dirname.count(os.sep) ** 0.5
        self.query_strings = [s for s in re.split("[&;]", query_str) if s]
        self.match_type = match_type

    def rank(self, item):
        # if self.whole_path_matching:
        #     part = item.filepath
        # else:
        #     part = item.filename
        part = item.match_target
        agg_score = 0.0
        match_start = len(part)
        match_end = -1
        for q in self.query_strings:
            match, score = self.match_and_score(q, part, self.match_type)
            if score is None or score == 0:
                # return None, None, None
                return None, None, None
            if score is not None:
                match_start = min(match_start, match.start())
                match_end = max(match_end, match.end())
                agg_score += score
        # return agg_score + self.weight_f(item), match_start, match_end
        return agg_score, match_start, match_end
# }}}2

class Controller(object): # {{{2

    ### Life-cycle

    def __init__(self, display, args):
        self.display = display
        self.args = args
        self.editor_path = os.environ.get("FUZZYSNAKE_EDITOR", os.environ.get("EDITOR", "vi"))

    ### Data Accession

    def scan_search_paths(self, items=None, exit_on_interrupt=False, interrupt_exit_value=1):
        if items is None:
            items = []
        respect_gitignores = not self.args.include_gitignores
        if self.args.directory_search_mode:
            ignore_directories = False
            ignore_files = True
        else:
            ignore_directories = True
            ignore_files = False
        if not self.args.search_paths:
            self.args.search_paths = ["."]
        try:
            for path in self.args.search_paths:
                if path == "-":
                    if sys.platform.startswith('win'):
                        raise NotImplementedError("Reading from standard input is not supported on this system at this time")
                    # NOTE: To allow us to continue to get input from the tty
                    # standard input in the curses window in the interactive loop,
                    # We do *not* read from `sys.stdin` directly here. Instead we open
                    # a new file object bound to the system file descriptor '0'
                    # (standard input), and read from that. After this is done and
                    # closed (using the context manager), we must set sys.stdin's
                    # file descriptor to the tty opened for reading.
                    #
                    # Alternate approach:
                    #
                    #   # if os.isatty(0):
                    #   #     exit(1)
                    #   # else:
                    #   #     # get stdin from tty
                    #   #     os.dup2(0, 3)
                    #   #     os.close(0)
                    #   #     my_stdin = os.fdopen(3, 'r')
                    #   #     sys.stdin = open('/dev/tty', 'r')
                    with os.fdopen(0, 'r') as src:
                        for item in src.read().split("\n"):
                            item = unicode_str(item)
                            item = os.path.expandvars(os.path.expanduser(item))
                            dirname = os.path.dirname(item)
                            basename = os.path.basename(item)
                            entry = Entry(dirname=dirname,
                                    filename=basename,
                                    score=len(items),
                                    match_start=0,
                                    match_end=0,
                                    whole_path_matching=False)
                            items.append(entry)
                    sys.stdin = open("/dev/tty", "r")
                else:
                    # Create a new sourcer on each pass.
                    # A little inefficient, but avoids cross-application
                    # of .gitignore etc. filters
                    ds = DirectorySource(
                            display=self.display,
                            target_filename_patterns=self.args.target_filename_pattern,
                            ignore_directories=ignore_directories,
                            ignore_files=ignore_files,
                            respect_gitignores=respect_gitignores,
                            include_hidden=self.args.include_hidden,
                            dirs_to_exclude=self.args.dirs_to_exclude,
                            files_to_exclude=self.args.files_to_exclude,
                            filter_for_glob_names=self.args.filter_for_glob_names,
                            max_recursion_depth=self.args.max_recursion_depth)
                    path = os.path.expandvars(os.path.expanduser(path))
                    ds.fetch(start_dir=path,
                            results=items,
                            suppress_progress_feedback=self.args.no_progress_window)
        except KeyboardInterrupt:
            if exit_on_interrupt:
                self.exit(interrupt_exit_value)
        return items

    def path_up(self):
        self.args.search_paths = sorted(set([os.path.normpath(os.path.relpath(os.path.abspath(os.path.join(path, os.pardir)))) for path in self.args.search_paths]))
        items = self.scan_search_paths()
        return items, self.get_search_path_info()

    def path_down(self, focal_item, selected_items):
        if self.args.directory_search_mode:
            new_dir = focal_item.filepath
            for sub_dir in os.listdir(new_dir):
                if os.path.isdir(os.path.join(new_dir, sub_dir)):
                    self.args.search_paths = [os.path.normpath(os.path.relpath(new_dir))]
                    break
            else:
                self.display.error("No valid sub-directories found in new search path(s)", erase=False)
                return None, None
            items = self.scan_search_paths()
            return items, self.get_search_path_info()
        else:
            filepaths = [entry.filepath for entry in selected_items]
            if not filepaths:
                self.display.error("No valid files found or selected", erase=False)
            else:
                self.apply_action(filepaths, as_subprocess=True)
            return None, None

    def get_search_path_info(self):
        if len(self.args.search_paths) == 1:
            search_path_info = "{}".format(os.path.normpath(os.path.abspath(self.args.search_paths[0])))
        else:
            search_path_info = "(multiple search paths)"
        return search_path_info

    def apply_action(self, filepaths, as_subprocess=False):
        self.display.stop()
        if self.args.action_type == "edit":
            execute_command(self.editor_path, filepaths, verbose=not self.args.quiet, as_subprocess=as_subprocess)
        elif self.args.action_type == "open":
            execute_command("open", filepaths, verbose=not self.args.quiet, as_subprocess=as_subprocess)
        elif self.args.action_type == "command":
            execute_command(self.args.action_target, filepaths, verbose=not self.args.quiet, as_subprocess=as_subprocess)
        elif self.args.action_type == "print":
            if not hasattr(self.args, "action_target") or self.args.action_target == "-":
                for filepath in filepaths:
                    sys.stdout.write(filepath)
                    sys.stdout.write("\n")
                    if not self.args.quiet:
                        sys.stderr.write(filepath)
                        sys.stderr.write("\n")
                if not as_subprocess:
                    self.exit(0)
            else:
                out = open(os.path.expandvars(os.path.expanduser(self.args.action_target)), "w")
                with out:
                    for filepath in filepaths:
                        out.write(filepath)
                        out.write("\n")
                if not as_subprocess:
                    self.exit(0)
        else:
            error_msg = "Unrecognized action: '{}'".format(args.action_type)
            if not as_subprocess:
                self.exit(error_msg)
            else:
                self.display.error(error_msg)

    def exit(self, exit_arg):
        self.display.stop()
        sys.exit(exit_arg)

    def run(self):
        selected = self.run_query()
        if not selected:
            self.exit(1) # raise error to let parent shell know nothing was selected
        filepaths = [entry.filepath for entry in selected]
        self.apply_action(filepaths, as_subprocess=False)

    def print_list(self,
            out=None,
            mirror_to_stderr=False):
        if out is None:
            out = sys.stdout
        items = self.scan_search_paths()
        self.display.stop()
        for item in items:
            item_str = "{}\n".format(item.filepath)
            out.write(item_str)
            if mirror_to_stderr:
                sys.stderr.write(item_str)

    def run_query(self):
        items = self.scan_search_paths()
        if not items:
            self.exit("No valid files or directories found.")
        ranker = FuzzyRanker
        selector = Selector(
                display=self.display,
                ranker=ranker,
                whole_path_matching=self.args.whole_path_match,
                match_type=self.args.match_type,
                multiselection_mode=self.args.multiselection_mode,
                path_up_fn=self.path_up,
                path_down_fn=self.path_down,
                search_path_info=self.get_search_path_info(),
                )
        try:
            selected = selector.run(items)
        except KeyboardInterrupt:
            self.exit(1) # error so no process will execute anything on blank output
        return selected

# }}}2

# }}}1

# CLI {{{1
# ==============================================================================

def parse_cli_args():  #{{{2
    parser = argparse.ArgumentParser(description=__description__)
    parser.add_argument("--version", action="version", version="FuzzySnake " + __version__)

    search_options_section = parser.add_argument_group("Search Options")
    search_options_section.add_argument(
            "search_paths",
            metavar="DIR",
            nargs="*",
            help="Top-level directory path(s) to search. Defaults to "
            "current directory ('{}').".format(os.curdir))
    search_options_section.add_argument(
            "-d", "--directory-paths",
            action="store_true",
            dest="directory_search_mode",
            default=False,
            help="Search for directory paths instead of filenames.")
    search_options_section.add_argument(
            "-r", "--recursion-limit", "--max-depth",
            dest="max_recursion_depth",
            type=int,
            help="Maximum depth of sub-directories to recursively search. "
            "If not specified, recursion depth is unlimited. If 0, then "
            "only the top-level directory is searched.")
    search_options_section.add_argument(
            "-s", "--single-selection",
            action="store_false",
            dest="multiselection_mode",
            default=True,
            help="Do not allow multiple entries to be marked/unmarked for selection using <TAB>.")
    search_options_section.add_argument(
            "-q", "--quiet",
            action="store_true",
            default=False,
            help="Run as silently as possible, e.g. do not echo commands being executed.")
    search_options_section.add_argument(
            "--no-progress-window",
            action="store_true",
            default=False,
            help="Do not show progress of filesystem scanning.")

    query_options_section = parser.add_argument_group("Query Options")
    query_options_section.add_argument(
            "-w", "--whole-path-match",
            action="store_true",
            default=False,
            help="Match against the *full* path of the file or directory, "
            "including the parent directory name. If not specified, by "
            "default, matching is agains the *basename* only. "
            "Use `<CTRL-W>` to toggle between whole path and basename matching "
            "during the search.")
    # query_options_section.add_argument(
    #         "-t", "--term-separator",
    #         dest="term_separator",
    #         default=";",
    #         help=
    #         "Specify the token to be used to separate multiple search "
    #         "terms in the query expression. Defaults to '%(default)s'. "
    #         "If multiple search terms are specified, a name has to "
    #         "independently match every search term. Thus, if '%(default)s' "
    #         "is given as the separator token, and 'foo%(default)sbar' is "
    #         "typed as a query pattern, then names have match both 'foo'"
    #         "AND 'bar'.")
    match_type_section = parser.add_argument_group("Match Mode Options",
            "The following flags set the initial matching mode to be used. "
            "You can cycle through match modes during a live search "
            "by typing `<CTRL-R>`.")
    match_type_group = match_type_section.add_mutually_exclusive_group()
    match_type_group.add_argument(
            "-f", "--fuzzy",
            action="store_const",
            dest="match_type",
            const="fuzzy",
            help="[DEFAULT] Fuzzy-matching mode: pattern is matched on a "
            "character-by-character basis, with characters required to "
            "occur in the same order as the pattern, but not necessarily "
            "consecutively (an arbitrary number of extra characters are "
            "allowed between matched characters).")
    match_type_group.add_argument(
            "-e", "--regexp",
            action="store_const",
            dest="match_type",
            const="regexp",
            help="Regular-expression mode: patterns are matched as full "
            "(Python) regular expression patterns.")
    match_type_group.add_argument(
            "-l", "--literal",
            action="store_const",
            dest="match_type",
            const="literal",
            help="Literal-matching mode: patterns are matched exactly as "
            "given.")
    parser.set_defaults(match_type="fuzzy")

    target_type_options = parser.add_argument_group("File Type Options",
            "Constrain the search to specific types of files. If one or "
            "more of the following are specified, then files of other "
            "types will be excluded."
            )
    target_type_options.add_argument(
            "--actionscript",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.as$|.*\.mxml$",
            help="ActionScript")
    target_type_options.add_argument(
            "--ada",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.ada$|.*\.adb$|.*\.ads$",
            help="Ada")
    target_type_options.add_argument(
            "--asm",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.asm$|.*\.s$",
            help="ASM")
    target_type_options.add_argument(
            "--asp",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.asp$",
            help="ASP")
    target_type_options.add_argument(
            "--aspx",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.master$|.*\.ascx$|.*\.asmx$|.*\.aspx$|.*\.svc$",
            help="ASPX")
    target_type_options.add_argument(
            "--autotools",
            action="append_const",
            dest="target_filename_pattern",
            const=r"Makefile.am|configure.ac",
            help="Autotools")
    target_type_options.add_argument(
            "--batch",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.bat$|.*\.cmd$",
            help="MS-DOS/Windows batch")
    target_type_options.add_argument(
            "--cfmx",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.cfc$|.*\.cfm$|.*\.cfml$",
            help="ColdFusion")
    target_type_options.add_argument(
            "--clojure",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.clj$",
            help="Clojure")
    target_type_options.add_argument(
            "--cmake",
            action="append_const",
            dest="target_filename_pattern",
            const=r"CMakeLists\.txt|.*\.cmake$",
            help="CMake")
    target_type_options.add_argument(
            "--coffeescript",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.coffee$",
            help="CoffeeScript")
    target_type_options.add_argument(
            "--cpp",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.cpp$|.*\.cc$|.*\.cxx$|.*\.c\+\+$|.*\.c$|.*\.m$|.*\.hpp$|.*\.hh$|.*\.h$|.*\.hxx|.*\.h\+\+$|.*\.inc$",
            help="C++ and C)")
    target_type_options.add_argument(
            "--csharp",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.cs$",
            help="C#")
    target_type_options.add_argument(
            "--css",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.css$",
            help="CSS")
    target_type_options.add_argument(
            "--dart",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.dart$",
            help="Dart")
    target_type_options.add_argument(
            "--delphi",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.pas$|.*\.int$|.*\.dfm$|.*\.nfm$|.*\.dof$|.*\.dpk$|.*\.dproj$|.*\.groupproj$|.*\.bdsgroup$|.*\.bdsproj$",
            help="Delphi")
    target_type_options.add_argument(
            "--elisp",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.el$",
            help="Emacs Lisp")
    target_type_options.add_argument(
            "--elixir",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.ex$|.*\.exs$",
            help="Elixir")
    target_type_options.add_argument(
            "--erlang",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.erl$|.*\.hrl$",
            help="Erlang")
    target_type_options.add_argument(
            "--fasta",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.fas$|.*\.fasta$",
            help="FASTA")
    target_type_options.add_argument(
            "--fortran",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.f$|.*\.f77$|.*\.f90$|.*\.f95$|.*\.f03$|.*\.for$|.*\.ftn$|.*\.fpp$",
            help="Fortran")
    target_type_options.add_argument(
            "--go",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.go$",
            help="Go")
    target_type_options.add_argument(
            "--groovy",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.groovy$|.*\.gtmpl$|.*\.gpp$|.*\.grunit$|.*\.gradle$",
            help="Groovy")
    target_type_options.add_argument(
            "--haskell",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.hs$|.*\.lhs$",
            help="Haskell")
    target_type_options.add_argument(
            "--html",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.htm$|.*\.html$",
            help="HTML")
    target_type_options.add_argument(
            "--java",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.java$|.*\.properties$",
            help="Java")
    target_type_options.add_argument(
            "--js",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.js$",
            help="JavaScript")
    target_type_options.add_argument(
            "--json",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.json$",
            help="JSON")
    target_type_options.add_argument(
            "--jsp",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.jsp$|.*\.jspx$|.*\.jhtm$|.*\.jhtml$",
            help="JavaServerPages")
    target_type_options.add_argument(
            "--julia",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.jl$",
            help="Julia")
    target_type_options.add_argument(
            "--less",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.less$",
            help="Less")
    target_type_options.add_argument(
            "--lisp",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.lisp$|.*\.lsp$",
            help="Lisp")
    target_type_options.add_argument(
            "--lua",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.lua$",
            help="Lua")
    target_type_options.add_argument(
            "--make",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.mk$|.*\.mak$|makefile|Makefile|GNUmakefile",
            help="Make")
    target_type_options.add_argument(
            "--markdown",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.mdown|.*\.markdown|.*\.md$",
            help="Markdown")
    target_type_options.add_argument(
            "--matlab",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.m$",
            help="MATLAB")
    target_type_options.add_argument(
            "--newick",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.dat$|.*\.tre$|.*\.newick$",
            help="Newick")
    target_type_options.add_argument(
            "--nexus",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.nex$|.*\.nexus$|.*\.nxs$|.*\.mb$|.*\trees$",
            help="NEXUS")
    target_type_options.add_argument(
            "--objc",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.m$|.*\.h$",
            help="Objective-C")
    target_type_options.add_argument(
            "--objcpp",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.mm$|.*\.h$",
            help="Objective-C++")
    target_type_options.add_argument(
            "--ocaml",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.ml$|.*\.mli$",
            help="OCaml")
    target_type_options.add_argument(
            "--parrot",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.pir$|.*\.pasm$|.*\.pmc$|.*\.ops$|.*\.pod$|.*\.pg$|.*\.tg$",
            help="Parrot")
    target_type_options.add_argument(
            "--pdf",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.pdf$",
            help="Adobe PDF (Portable Document Format) files")
    target_type_options.add_argument(
            "--perl",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.pl$|.*\.pm$|.*\.pod$|.*\.t$|.*\.psgi$",
            help="Perl")
    target_type_options.add_argument(
            "--perl-test",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.t$",
            help="Perl test")
    target_type_options.add_argument(
            "--php",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.php$|.*\.phpt$|.*\.php3$|.*\.php4$|.*\.php5$|.*\.phtml$",
            help="PHP")
    target_type_options.add_argument(
            "--phylogenetics",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.nex$|.*\.nexus$|.*\.nxs$|.*\.mb$|.*\.fas$|.*\.fasta$|.*\.tre$|.*\.trees$|.*\.xml$|.*\.dat$|.*\.nexml$|.*\.newick$|.*\.phylip$|.*\.aln$",
            help="Phylogenetics")
    target_type_options.add_argument(
            "--plone",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.pt$|.*\.cpt$|.*\.metadata$|.*\.cpy$|.*\.py$",
            help="Plone")
    target_type_options.add_argument(
            "--python",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.py$",
            help="Python")
    target_type_options.add_argument(
            "--rake",
            action="append_const",
            dest="target_filename_pattern",
            const=r"Rakefile",
            help="Rake")
    target_type_options.add_argument(
            "--r",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.R$|.*\.r$",
            help="R")
    target_type_options.add_argument(
            "--rst",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.rst$|.*\.txt$|.*\.inc$",
            help="ReStructuredText")
    target_type_options.add_argument(
            "--ruby",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.rb$|.*\.rhtml$|.*\.rjs$|.*\.rxml$|.*\.erb$|.*\.rake$|.*\.spec$|Rakefile",
            help="Ruby")
    target_type_options.add_argument(
            "--rust",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.rs$",
            help="Rust")
    target_type_options.add_argument(
            "--sass",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.sass$|.*\.scss$",
            help="Sass")
    target_type_options.add_argument(
            "--scala",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.scala$",
            help="Scala")
    target_type_options.add_argument(
            "--scheme",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.scm$|.*\.ss$",
            help="Scheme")
    target_type_options.add_argument(
            "--shell",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.sh$|.*\.bash$|.*\.csh$|.*\.tcsh$|.*\.ksh$|.*\.zsh$|.*\.fish$",
            help="shell")
    target_type_options.add_argument(
            "--smalltalk",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.st$",
            help="Smalltalk")
    target_type_options.add_argument(
            "--sphinx",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.rst$|.*\.inc$|conf\.py",
            help="Sphinx")
    target_type_options.add_argument(
            "--sql",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.sql$|.*\.ctl$",
            help="SQL")
    target_type_options.add_argument(
            "--tcl",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.tcl$|.*\.itcl$|.*\.itk$",
            help="TCl")
    target_type_options.add_argument(
            "--tex",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.tex$|.*\.bib$",
            help="TeX")
    target_type_options.add_argument(
            "--text",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.txt$",
            help="Plain text")
    target_type_options.add_argument(
            "--tt",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.tt$|.*\.tt2$|.*\.ttml$",
            help="TT")
    target_type_options.add_argument(
            "--vb",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.bas$|.*\.cls$|.*\.frm$|.*\.ctl$|.*\.vb$|.*\.resx$",
            help="VisualBasic")
    target_type_options.add_argument(
            "--verilog",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.v$|.*\.vh$|.*\.sv$",
            help="Verilog")
    target_type_options.add_argument(
            "--vhdl",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.vhd$|.*\.vhdl$",
            help="VHDL")
    target_type_options.add_argument(
            "--vim",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.vim$",
            help="Vim")
    target_type_options.add_argument(
            "--xml",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.xml$|.*\.dtd$|.*\.xsl$|.*\.xslt$|.*\.ent$",
            help="XML")
    target_type_options.add_argument(
            "--yaml",
            action="append_const",
            dest="target_filename_pattern",
            const=r".*\.yaml$|.*\.yml$",
            help="YAML")

    custom_filtering_options_group = parser.add_argument_group("Custom Filtering Options")
    custom_filtering_options_group.add_argument(
            "-n", "--name-glob",
            dest="filter_for_glob_names",
            action="append",
            metavar="GLOB-PATTERN",
            help= "General glob pattern to match against basenames of "
            " files and directories to be included (e.g., '*.log', 'res??[0-9].*')."
            " Multiple patterns can be be specified by repeating the option,"
            " e.g.: \"-n '*.log -n *.run.log -n *.screen.log'\","
            " in which case the files or directories with basenames that"
            " match *any* of the specified glob patterns will be included."
            " Files and directories with names that do not match any of the"
            " glob patterns will excluded, unless specifically included"
            " through other target criteria.")
    custom_filtering_options_group.add_argument(
            "-D", "--exclude-dir-patterns",
            action="append",
            metavar="PATTERN",
            dest="dirs_to_exclude",
            help="Regular expression patterns to be matched to directory "
            "names(s) to exclude. Multiple path patterns may be specified "
            "by repeating the option, e.g.: '-D path1 -D path2 -D path3'.")
    custom_filtering_options_group.add_argument(
            "-F", "--exclude-file-patterns",
            action="append",
            metavar="PATTERN",
            dest="files_to_exclude",
            help="Regular expression patterns to be matched to filename(s) "
            "to exclude. Multiple path patterns may be specified by "
            "repeating the option, e.g.: '-F path1 -F path2 -F path3'.")
    custom_filtering_options_group.add_argument(
            "-a", "--include-hidden",
            action="store_true",
            default=False,
            help="Do not filter out hidden files and directories "
            "(by default, these are filtered out).")
    custom_filtering_options_group.add_argument(
            "--include-gitignores",
            action="store_true",
            default=False,
            help="Do not filter out paths specified in '.gitignore' "
            "(by default, these are filtered out).")

    action_group_section = parser.add_argument_group("Action Options")
    action_group = action_group_section.add_mutually_exclusive_group()
    action_group.add_argument(
            "-E", "--edit",
            action="store_const",
            dest="action_type",
            const="edit",
            help="[DEFAULT] Opens selected file or directory for editing "
            "(with editor program specified by, in order of resolution, "
            "'$FUZZYSNAKE_EDITOR' or '$EDITOR').")
    action_group.add_argument(
            "-p", "--print",
            action=SetPrintAction,
            dest="action_type",
            metavar="FILEPATH",
            help="Prints the selected file or directory name to FILEPATH.")
    action_group.add_argument(
            "--stdout",
            action=SetPrintAction,
            dest="action_type",
            nargs=0,
            metavar="FILEPATH",
            help="Prints the selected file or directory name to standard output.")
    action_group.add_argument(
            "-o", "--open",
            action="store_const",
            dest="action_type",
            const="open",
            help="Passes the selected file or directory path as an argument to the 'open' command.")
    action_group.add_argument(
            "-c", "--execute-command",
            action=SetCustomCommandAction,
            dest="action_type",
            metavar="COMMAND",
            help="Execute `COMMAND` with the selected file or directory path name as an argument. "
            "If the token '{}' occurs in the COMMAND string, it will be replaced with the "
            "selected file or directory path name. If this token is not found in the COMMAND "
            "string, then the execution string will be COMMAND as-is followed by the selected "
            "file or directory path name.")
    action_group.add_argument(
            "-L", "--list-and-exit",
            action="store_const",
            dest="action_type",
            const="list-and-exit",
            help="[SPECIAL] Instead of listing the names of files and directories found for "
            "you to select a particular one, print the names to standard output. This option "
            "allows you to do, e.g., 'vim $(fz -L --python src/)' to quickly open all the "
            "Python files in the 'src/' subdirectory)")
    parser.set_defaults(action_type="edit")

    return parser.parse_args()
# }}}2

class SetPrintAction(argparse.Action): # {{{2
    def __call__(self,
            parser,
            namespace,
            values,
            option_string=None):
        namespace.action_type = "print"
        if option_string == "--stdout":
            namespace.action_target = "-"
        else:
            namespace.action_target = values
# }}}2

class SetCustomCommandAction(argparse.Action): # {{{2
    def __call__(self,
            parser,
            namespace,
            values,
            option_string=None):
        namespace.action_type = "command"
        namespace.action_target = values
# }}}2

# }}}1

def main(): # {{{1
    args = parse_cli_args()
    with Subscreen() as stdscr:
        display = Display(stdscr=stdscr)
        controller = Controller(display=display, args=args)
        if args.action_type == "list-and-exit":
            controller.print_list()
        else:
            controller.run()
# }}}1

if __name__ == '__main__': # {{{1
    main()
# }}}1

